{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/* eslint-disable no-param-reassign */\n\n\nimport * as React from 'react';\nimport raf from \"rc-util/es/raf\";\nexport default function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop) {\n  var scrollRef = React.useRef();\n  return function (arg) {\n    raf.cancel(scrollRef.current);\n\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && _typeof(arg) === 'object') {\n      var index;\n      var align = arg.align;\n\n      if ('index' in arg) {\n        index = arg.index;\n      } else {\n        index = data.findIndex(function (item) {\n          return getKey(item) === arg.key;\n        });\n      } // We will retry 3 times in case dynamic height shaking\n\n\n      var syncScroll = function syncScroll(times, targetAlign) {\n        if (times < 0 || !containerRef.current) return;\n        var height = containerRef.current.clientHeight;\n        var needCollectHeight = false;\n        var newTargetAlign = targetAlign; // Go to next frame if height not exist\n\n        if (height) {\n          var mergedAlign = targetAlign || align; // Get top & bottom\n\n          var stackTop = 0;\n          var itemTop = 0;\n          var itemBottom = 0;\n\n          for (var i = 0; i <= index; i += 1) {\n            var key = getKey(data[i]);\n            itemTop = stackTop;\n            var cacheHeight = heights.get(key);\n            itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n            stackTop = itemBottom;\n\n            if (i === index && cacheHeight === undefined) {\n              needCollectHeight = true;\n            }\n          } // Scroll to\n\n\n          var targetTop = null;\n\n          switch (mergedAlign) {\n            case 'top':\n              targetTop = itemTop;\n              break;\n\n            case 'bottom':\n              targetTop = itemBottom - height;\n              break;\n\n            default:\n              {\n                var scrollTop = containerRef.current.scrollTop;\n                var scrollBottom = scrollTop + height;\n\n                if (itemTop < scrollTop) {\n                  newTargetAlign = 'top';\n                } else if (itemBottom > scrollBottom) {\n                  newTargetAlign = 'bottom';\n                }\n              }\n          }\n\n          if (targetTop !== null && targetTop !== containerRef.current.scrollTop) {\n            syncScrollTop(targetTop);\n          }\n        } // We will retry since element may not sync height as it described\n\n\n        scrollRef.current = raf(function () {\n          if (needCollectHeight) {\n            collectHeight();\n          }\n\n          syncScroll(times - 1, newTargetAlign);\n        });\n      };\n\n      syncScroll(3);\n    }\n  };\n}","map":{"version":3,"sources":["/home/diegozago/Documents/hi-platform-test/node_modules/rc-virtual-list/es/hooks/useScrollTo.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","React","raf","useScrollTo","containerRef","data","heights","itemHeight","getKey","collectHeight","syncScrollTop","scrollRef","useRef","arg","cancel","current","index","align","findIndex","item","key","syncScroll","times","targetAlign","height","clientHeight","needCollectHeight","newTargetAlign","mergedAlign","stackTop","itemTop","itemBottom","i","cacheHeight","get","undefined","targetTop","scrollTop","scrollBottom"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-disable no-param-reassign */\nimport * as React from 'react';\nimport raf from \"rc-util/es/raf\";\nexport default function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop) {\n  var scrollRef = React.useRef();\n  return function (arg) {\n    raf.cancel(scrollRef.current);\n\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && _typeof(arg) === 'object') {\n      var index;\n      var align = arg.align;\n\n      if ('index' in arg) {\n        index = arg.index;\n      } else {\n        index = data.findIndex(function (item) {\n          return getKey(item) === arg.key;\n        });\n      } // We will retry 3 times in case dynamic height shaking\n\n\n      var syncScroll = function syncScroll(times, targetAlign) {\n        if (times < 0 || !containerRef.current) return;\n        var height = containerRef.current.clientHeight;\n        var needCollectHeight = false;\n        var newTargetAlign = targetAlign; // Go to next frame if height not exist\n\n        if (height) {\n          var mergedAlign = targetAlign || align; // Get top & bottom\n\n          var stackTop = 0;\n          var itemTop = 0;\n          var itemBottom = 0;\n\n          for (var i = 0; i <= index; i += 1) {\n            var key = getKey(data[i]);\n            itemTop = stackTop;\n            var cacheHeight = heights.get(key);\n            itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n            stackTop = itemBottom;\n\n            if (i === index && cacheHeight === undefined) {\n              needCollectHeight = true;\n            }\n          } // Scroll to\n\n\n          var targetTop = null;\n\n          switch (mergedAlign) {\n            case 'top':\n              targetTop = itemTop;\n              break;\n\n            case 'bottom':\n              targetTop = itemBottom - height;\n              break;\n\n            default:\n              {\n                var scrollTop = containerRef.current.scrollTop;\n                var scrollBottom = scrollTop + height;\n\n                if (itemTop < scrollTop) {\n                  newTargetAlign = 'top';\n                } else if (itemBottom > scrollBottom) {\n                  newTargetAlign = 'bottom';\n                }\n              }\n          }\n\n          if (targetTop !== null && targetTop !== containerRef.current.scrollTop) {\n            syncScrollTop(targetTop);\n          }\n        } // We will retry since element may not sync height as it described\n\n\n        scrollRef.current = raf(function () {\n          if (needCollectHeight) {\n            collectHeight();\n          }\n\n          syncScroll(times - 1, newTargetAlign);\n        });\n      };\n\n      syncScroll(3);\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}